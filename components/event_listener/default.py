# Auto generated by LangBot Plugin SDK.
# Please refer to https://docs.langbot.app/en/plugin/dev/tutor.html for more details.
from __future__ import annotations
import os
import sys
import yaml
import importlib.util
import logging
from typing import Dict, Any
from langbot_plugin.api.definition.components.common.event_listener import EventListener
from langbot_plugin.api.entities import events, context
from apscheduler.schedulers.asyncio import AsyncIOScheduler
from apscheduler.triggers.cron import CronTrigger
from langbot_plugin.api.entities.builtin.platform import message as platform_message
from langbot_plugin.api.entities.builtin.provider import message as provider_message
from pytz import timezone 
from datetime import datetime

# 配置日志
logging.basicConfig(level=logging.INFO, format='%(asctime)s - %(name)s - %(levelname)s - %(message)s')
logger = logging.getLogger('TaskTimer')


class DefaultEventListener(EventListener):
    
    def __init__(self):
        super().__init__()
        # 任务调度器
        self.scheduler = None
        # 配置文件路径
        self.config_file = os.path.join(os.path.dirname(os.path.dirname(os.path.dirname(os.path.abspath(__file__)))), 'config', 'tasks.yaml')
        # 功能脚本目录
        self.func_dir = os.path.join(os.path.dirname(os.path.dirname(os.path.dirname(os.path.abspath(__file__)))), 'func')
        # 存储从event_context获取的bot_uuid
        self.bot_uuid = None
        
    async def initialize(self):
        await super().initialize()
        
        # 初始化任务调度器
        self.scheduler = AsyncIOScheduler(timezone=timezone('Asia/Shanghai'))
        
        self.bot_uuid = self.plugin.get_config().get("bot_uuid", None)
        self.zaobao_cron = self.plugin.get_config().get("zaobao_cron", "0 8 * * *")
        self.zaobao_target_type = self.plugin.get_config().get("zaobao_target_type", "group")
        self.zaobao_target_id = self.plugin.get_config().get("zaobao_target_id", None)
        print(f'bot_uuid from config: {self.bot_uuid}')

        # 启动任务调度器
        await self.start_scheduler()
        # 注册PersonMessageReceived事件处理器
        @self.handler(events.PersonMessageReceived)
        async def handler(event_context: context.EventContext):
            # bot_uuid = self.plugin.get_config().get("bot_uuid", None)
            # print(f'bot_uuid from config: {bot_uuid}')
            # print("Hello LangBot Plugin!")
            # print(f'bot_uuid: {bot_uuid}\nevent_context: {event_context}')
            message_chain = event_context.event.message_chain
            print(f'message_chain: {message_chain}')
            # 将message_chain转换为字符串后进行比较
            if str(message_chain) == 'TaskTimer':
                bot_uuid = await event_context.get_bot_uuid()
                if bot_uuid != self.bot_uuid:
                    await event_context.reply(
                        platform_message.MessageChain([
                            platform_message.Plain(text=f"当前bot_uuid: {bot_uuid}\n与配置文件中的不一致，请检查！"),
                        ])
                    )
                else:
                    await event_context.reply(
                        platform_message.MessageChain([
                            platform_message.Plain(text=f"当前bot_uuid: {bot_uuid}\n与配置文件中的一致，配置正确！"),
                        ])
                    )
            elif str(message_chain) == 'TaskTimer':
                bot_uuid = await event_context.get_bot_uuid()
                await event_context.reply(
                    platform_message.MessageChain([
                        platform_message.Plain(text=f"bot_uuid: {bot_uuid}\n请将bot_uuid添加到WebUI插件配置处"),
                    ])
                )
            return
        
    async def start_scheduler(self):
        """\启动任务调度器并加载配置的定时任务"""
        try:
            # 加载配置文件
            tasks_config = self.load_tasks_config()
            
            if not tasks_config or 'tasks' not in tasks_config:
                logger.warning("配置文件为空或格式不正确，未加载任何定时任务")
                return
            
            # 加载并调度每个任务
            for task in tasks_config['tasks']:
                if task.get('enabled', False):
                    await self.schedule_task(task)
            
            # 启动调度器
            if self.scheduler.get_jobs():
                self.scheduler.start()
                logger.info(f"任务调度器已启动，共加载了 {len(self.scheduler.get_jobs())} 个任务")
            else:
                logger.info("没有启用的定时任务，调度器未启动")
                
        except Exception as e:
            logger.error(f"启动任务调度器时发生错误: {str(e)}")
            
    def load_tasks_config(self) -> Dict[str, Any]:
        """加载YAML配置文件"""
        # 如果配置文件不存在，尝试使用示例配置文件
        if not os.path.exists(self.config_file):
            example_config_file = os.path.join(os.path.dirname(self.config_file), 'tasks.yaml.example')
            if os.path.exists(example_config_file):
                logger.warning(f"配置文件不存在，使用示例配置文件: {example_config_file}")
                self.config_file = example_config_file
            else:
                logger.error(f"配置文件和示例配置文件均不存在: {self.config_file}")
                return {}
        
        try:
            with open(self.config_file, 'r', encoding='utf-8') as f:
                return yaml.safe_load(f)
        except Exception as e:
            logger.error(f"加载配置文件时发生错误: {str(e)}")
            return {}
            
    async def schedule_task(self, task: Dict[str, Any]):
        """根据任务配置调度定时任务"""
        try:

            # 检查是否是早报任务
            if task.get('script') == 'zaobao_image.py':
                logger.info(f"检测到早报任务，使用配置的默认参数覆盖")
                task['schedule'] = self.zaobao_cron
                task['target_type'] = self.zaobao_target_type
                task['target_id'] = self.zaobao_target_id

            schedule = task.get('schedule')
            script = task.get('script')
            description = task.get('description', f'执行脚本: {script}')
            
            if not schedule or not script:
                logger.warning(f"任务配置不完整，忽略该任务: {task}")
                return
            
            # 解析cron表达式
            cron_parts = schedule.split()
            if len(cron_parts) != 5:
                logger.error(f"无效的cron表达式: {schedule}")
                return
            
            # 添加任务到调度器，传递整个task对象
            self.scheduler.add_job(
                self.execute_script, 
                CronTrigger.from_crontab(schedule, timezone=timezone('Asia/Shanghai')),
                args=[task],  # 传递整个task对象，包含所有配置信息
                name=description
            )
            
            logger.info(f"已添加定时任务: {description} (cron: {schedule})")
            
        except Exception as e:
            logger.error(f"调度任务时发生错误: {str(e)}")
            
    async def execute_script(self, task: Dict[str, Any]):
        """执行指定的Python脚本并发送结果"""
        try:
            script_file = task.get('script')
            script_path = os.path.join(self.func_dir, script_file)
            
            if not os.path.exists(script_path):
                logger.error(f"脚本文件不存在: {script_path}")
                return
            
            # 动态导入并执行脚本
            module_name = os.path.splitext(os.path.basename(script_file))[0]
            
            # 从文件加载模块
            spec = importlib.util.spec_from_file_location(module_name, script_path)
            if spec and spec.loader:
                module = importlib.util.module_from_spec(spec)
                sys.modules[module_name] = module
                spec.loader.exec_module(module)
                
                # 如果脚本有execute函数，调用它
                if hasattr(module, 'execute') and callable(module.execute):
                    logger.info(f"执行脚本: {script_file}")
                    try:
                        result = await module.execute()
                        if result:
                            logger.info(f"脚本执行结果: {result}")
                            
                            # 获取发送消息所需的信息
                            target_type = task.get('target_type', 'person')  # 默认发送给个人
                            target_id = task.get('target_id', None)  # 目标ID
                            
                            # 如果有指定目标ID，则发送消息
                            if target_id:
                                try:
                                    # 构建消息链
                                    message_chain = []
                                    
                                    # 检查结果是否包含markdown格式的图片
                                    # 匹配 ![alt text](image_url) 格式
                                    import re
                                    markdown_image_pattern = r'!\[(.*?)\]\((http[s]?:\/\/[^)]+)\)'  # 匹配markdown图片格式
                                    match = re.search(markdown_image_pattern, str(result))
                                    
                                    if match:
                                        # 如果是markdown图片格式，提取图片URL并创建Image消息
                                        image_url = match.group(2)
                                        message_chain.append(platform_message.Image(url=image_url))
                                        
                                        # 如果还有其他文本内容，添加为Plain消息
                                        plain_text = re.sub(markdown_image_pattern, '', str(result)).strip()
                                        if plain_text:
                                            message_chain.append(platform_message.Plain(text=plain_text))
                                    else:
                                        # 普通文本消息
                                        message_chain.append(platform_message.Plain(text=str(result)))
                                    
                                    # 发送消息
                                    await self.plugin.send_message(
                                        bot_uuid=self.bot_uuid,  # 使用从event_context获取的bot_uuid
                                        target_type=target_type,
                                        target_id=target_id,
                                        message_chain=platform_message.MessageChain(message_chain),
                                    )
                                    logger.info(f"已发送脚本执行结果到 {target_type} {target_id}")
                                except Exception as e:
                                    logger.error(f"发送消息时发生错误: {str(e)}")
                    except Exception as e:
                        logger.error(f"执行脚本的execute函数时发生错误: {str(e)}")
                else:
                    logger.info(f"脚本已加载，但未找到execute函数: {script_file}")
            else:
                logger.error(f"无法从文件加载模块: {script_path}")
                
        except Exception as e:
            logger.error(f"执行脚本时发生错误: {str(e)}")
            
    async def terminate(self):
        """停止任务调度器"""
        if self.scheduler and self.scheduler.running:
            self.scheduler.shutdown()
            logger.info("任务调度器已停止")
        
        await super().terminate()
        